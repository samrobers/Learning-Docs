GraphQL 

Uses a SDL, Schema Definition Language

Example Defining simple types

```
type Person {
    name: String! 
    age: Int! 
}

Type Post {
    title: String!
}

```
Adding a Relation 

```
type Person {
    name: String! 
    age: Int! 
    posts: [Post!]!
}

Type Post {
    title: String!
    author: Person!
}
```
This syntax specifies that a person can have many posts, and a post has one author 
this is a one to many relationship


Writing Graphql Quieries

With restful api data is loaded from specific endpoints and is clearly defined structure of the information it returns 

Graphql only expose a single endpoint and the structure of the data is not fixed, and the client decides what data is needed

Example of a query

```
/** AllPersons field is root of query, and everything following the root field is the payload of the query
/** Basic Query Example 

{
    allPersons{
        name 
    }
}

/** Example response 
{
    "allPersons": {
        {
            "name": "Johny"
        },
        {
            "name": "Sarah"
        },
        {
            "name": "Alice"
        }
    }
}

```

IF we wanted the age to be included, we must include that as well. Instead of just the age

To iclude this, we just need to adjust the payload

```
{
    allPersons{
        name 
        age
    }
}

/** Example response 
{
    "allPersons": {
        {
            "name": "Johny", "age": 23
        },
        {
            "name": "Sarah", "age": 25
        },
        {
            "name": "Alice", "age": 30
        }
    }
}

```


Note: In a graphql query it can have 0 or more arguments if specified within the schema 


IF you wanted to load all of the posts that are included from a user here is a example 

```
{
    allPersons {
        name
          posts {
              title
          }
    }
}
```

Example return data 

```
  "allPersons": {
        {
            "name": "Johny",
            "posts": [
                {"title": "graphql is awesome" },
                {"title": "graphql is cool" }
                            ]
        },
        {
            "name": "everyone else",
            "posts": [
                {"title": "graphql is awesome" },
                {"title": "graphql is cool" }
                            ]
        },
```

Making Changes to Data in the Backend 
This is done through mutations 
3 kinds of mutations 
creating 
updating 
deleting 
Regular syntactic structure as 


example 

```
mutation {
    createPerson(name: "Bob", age: 36){
        name 
        age
    }
}
```
The create person field takes in 2 arguments and will have the payload of 2 

The return from the server example 

```
{
    "createPerson": {
        "name" : "Bob, 
        "age" : 36
    }
}

One pattern is that graphql types have unique id types generated by the server

```
Person {
    id: ID!
    name: String!
    age: Int!
}

```

```
mutation {
    createPerson(name: "Bob", age: 36){
        id
    }
}
```
Now when a person is created you can directly as for the id, which was not available before hand 

 The GraphQL Schema 

one of the most important parts of working with a graphql api 

it defines the capabilites of the api by specifying hoq a cliente and fetch and update data

represents contract between client and server


schema is a collection of graphql tytpes


Root Types 
```
type Query {
   
}

Type Mutation {

}

Type Subscription {


}
```


The Query Type 

To use the allPersons query we used as a example in the beginning 

```
query {
    allPersons {
        name 
    }
}
```
We need to add the corresponding query to our types 

```
type Query {
    allPersons: [Person! ]!

}



The Mutation Type 

to use the mutation type create person 

```
mutation {
    createPerson(name: "Bob", age: 36){
        id
    }
}
```
we would define the type as 

```
type Mutation {
    createPerson(name: String!, age: String!): Person!
}
```

Skipping subscription type 


Full Crud Examples of all 

```
type Person {
    id: ID!
    name: String!
    age: Int!
    posts: [Post!]!
}

type Post {
    id: ID!
    title: String!
    author: Person!
}

type Query {
    allPersons: [Person!]!
    allPosts: [Post!]!
}

type Mutation {
    createPerson(name: String!, age: String!): Person!
    updatePerson(id: ID!,name: String!, age: String!): Person!
    deletePerson(id: ID!): Person!
    createPost(title: String!): Post!
    updatePost(id: ID!, title: String!): Post!
    deletePost(id: ID!): Post!
}

```

We are missing a few, but here are a general few of how to get it done 


```
type Query {
  user(id: ID!): User
}
```

